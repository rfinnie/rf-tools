#!/usr/bin/env python3

# SPDX-PackageSummary: rfrtl433
# SPDX-FileCopyrightText: © 2025 Ryan Finnie <ryan@finnie.org>
# SPDX-License-Identifier: MPL-2.0

import argparse
import json
import logging
import os
import pathlib
import subprocess
import sys

import paho.mqtt.client as mqtt
import yaml


class RFRTL433:
    def __init__(self):
        self.seen = []

    def on_connect(self, client, userdata, flags, reason_code, **kwargs):
        logging.info("Connected with result code {}".format(reason_code))
        client.subscribe("$SYS/broker/uptime")

    def on_message(self, client, userdata, msg, **kwargs):
        logging.debug("{}: {}".format(msg.topic, msg.payload))

    def parse_args(self, argv=None):
        if argv is None:
            argv = sys.argv

        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
            prog=os.path.basename(argv[0]),
        )

        parser.add_argument(
            "--config",
            type=pathlib.Path,
            default=os.path.join(
                os.environ.get(
                    "XDG_CONFIG_HOME",
                    os.path.join(os.path.expanduser("~"), ".config", "rfrtl433"),
                ),
                "rfrtl433.yaml",
            ),
            help="Configuration file",
        )

        parser.add_argument(
            "--debug",
            action="store_true",
            help="output additional debugging information",
        )

        return parser.parse_args(args=argv[1:])

    def load_config(self):
        with self.args.config.open() as f:
            self.config = yaml.safe_load(f)
        self.config["mqtt"] = self.config.get("mqtt", {})
        self.config["devices"] = self.config.get("devices", {})

    def process_line(self, line):
        try:
            j = json.loads(line)
        except json.decoder.JSONDecodeError:
            logging.exception("JSON decode error")
            return
        logging.debug("Received: {}".format(j))
        if j["protocol"] != 12:
            return
        device_id = "rtl433_{}_{}_{}".format(j["protocol"], j["id"], j["channel"])
        path = "{}/{}".format(self.config["mqtt"].get("prefix", "home"), device_id)
        if (device_id not in self.config["devices"]) and (
            not self.config.get("publish_unknown_devices", True)
        ):
            return
        friendly_name = self.config["devices"][device_id].get("name", device_id)

        self.mqttc.publish(
            "{}/state/temperature".format(path),
            ((j["temperature_C"] * (9.0 / 5.0)) + 32),
        )
        self.mqttc.publish("{}/state/humidity".format(path), j["humidity"])

        if device_id not in self.seen:
            logging.info("{} ({}) seen for the first time, publishing HA autodiscovery".format(device_id, friendly_name))
            self.seen.append(device_id)
            payload = {
                "dev": {
                    "ids": device_id,
                    "name": friendly_name,
                    "mdl": j["model"],
                },
                "o": {
                    "name": "rfrtl433",
                    "sw": "1.0",
                    "url": "https://github.com/rfinnie/rf-tools",
                },
                "cmps": {
                    "{}_t".format(device_id): {
                        "p": "sensor",
                        "device_class": "temperature",
                        "unit_of_measurement": "°F",
                        "state_topic": "{}/state/temperature".format(path),
                        "unique_id": "{}_t".format(device_id),
                    },
                    "{}_h".format(device_id): {
                        "p": "sensor",
                        "device_class": "humidity",
                        "unit_of_measurement": "%",
                        "state_topic": "{}/state/humidity".format(path),
                        "unique_id": "{}_h".format(device_id),
                    },
                },
                "qos": 2,
            }
            self.mqttc.publish(
                "homeassistant/device/{}/config".format(device_id),
                json.dumps(payload),
                retain=True,
            )

    def main(self):
        self.args = self.parse_args()
        logging.basicConfig(level=(logging.DEBUG if self.args.debug else logging.INFO))
        self.load_config()

        self.mqttc = mqtt.Client()
        self.mqttc.on_connect = self.on_connect
        self.mqttc.on_message = self.on_message
        if self.config["mqtt"].get("username"):
            self.mqttc.username_pw_set(
                username=self.config["mqtt"]["username"],
                password=self.config["mqtt"]["password"],
            )
        self.mqttc.connect(
            self.config["mqtt"]["host"], self.config["mqtt"].get("port", 1883), 60
        )

        self.mqttc.loop_start()

        rtl_433_command = self.config.get(
            "rtl_433_command",
            ["rtl_433", "-F", "json", "-v", "-M", "level", "-M", "protocol"],
        )
        proc = subprocess.Popen(rtl_433_command, stdout=subprocess.PIPE)
        while True:
            line = proc.stdout.readline()
            if not line:
                break
            self.process_line(line)

        self.mqttc.loop_stop()


if __name__ == "__main__":
    sys.exit(RFRTL433().main())
