#!/usr/bin/python3

# SPDX-FileComment: sslchecker-prometheus
# SPDX-FileCopyrightText: Copyright (C) 2021 Ryan Finnie
# SPDX-License-Identifier: MPL-2.0

# Usage: sslchecker-prometheus config.yaml
#
# Sample config.yaml:
# write_file: /var/lib/prometheus/node-exporter/sslchecker.prom
# hosts:
# - hostname: www.example.com
#   port: 443
# - hostname: smtp.example.com
#   port: 25
#   type: starttls
# - hostname: ftp.example.com
#   port: 21
#   type: auth_tls
# - hostname: imap.example.com
#   port: 993
# - hostname: mumble.example.com
#   port: 64738

import datetime
import logging
import os
import socket
import ssl
import sys
import time

from cryptography import x509
from cryptography.hazmat.backends import default_backend
from prometheus_client import CollectorRegistry, Gauge, write_to_textfile
import yaml


CONFIG = {}


def dump_metrics():
    registry = CollectorRegistry()
    sslchecker_time_seconds = Gauge(
        "sslchecker_time_seconds",
        "Current time, seconds since epoch",
        registry=registry,
    )
    sslchecker_retrieval_success_boolean = Gauge(
        "sslchecker_retrieval_success_boolean",
        "1 for successful retrieval, 0 for failure",
        ["server_hostname", "server_port"],
        registry=registry,
    )
    sslchecker_not_before_seconds = Gauge(
        "sslchecker_not_before_seconds",
        "Not Before time of certificate, seconds since epoch",
        ["server_hostname", "server_port", "certificate_cn", "issuer_cn"],
        registry=registry,
    )
    sslchecker_not_after_seconds = Gauge(
        "sslchecker_not_after_seconds",
        "Not After time of certificate, seconds since epoch",
        ["server_hostname", "server_port", "certificate_cn", "issuer_cn"],
        registry=registry,
    )
    sslchecker_serial_number = Gauge(
        "sslchecker_serial_number",
        "Serial number of certificate",
        ["server_hostname", "server_port", "certificate_cn", "issuer_cn"],
        registry=registry,
    )

    for host in sorted(CONFIG["hosts"], key=lambda x: (x["hostname"], x["port"])):
        hostname = host["hostname"]
        port = host["port"]
        try:
            res = check_host(host)
        except Exception:
            logging.exception("Error on {}:{}".format(hostname, port))
            sslchecker_retrieval_success_boolean.labels(hostname, str(port)).set(0)
            continue
        sslchecker_retrieval_success_boolean.labels(hostname, str(port)).set(1)
        labels = (hostname, str(port), res[3], res[4])

        sslchecker_serial_number.labels(*labels).set(res[0])
        sslchecker_not_before_seconds.labels(*labels).set(res[1].timestamp())
        sslchecker_not_after_seconds.labels(*labels).set(res[2].timestamp())
    sslchecker_time_seconds.set(time.time())
    write_to_textfile(CONFIG["write_file"], registry)


def check_host(host):
    hostname = host["hostname"]
    port = host["port"]
    now = datetime.datetime.now()
    addr = socket.getaddrinfo(hostname, port)[0]
    sock = socket.socket(addr[0], addr[1], addr[2])
    sock.settimeout(10)
    sock.connect(addr[4])
    if host.get("type") == "starttls":
        # Usually SMTP (port 25)
        sock.recv(1024)
        sock.send(b"STARTTLS\r\n")
        sock.recv(1024)
    elif host.get("type") == "auth_tls":
        # Usually FTP (port 21)
        sock.recv(1024)
        sock.send(b"AUTH TLS\r\n")
        sock.recv(1024)

    ssl_context = ssl.SSLContext()
    ssl_sock = ssl_context.wrap_socket(sock, server_hostname=hostname)
    der_data = ssl_sock.getpeercert(True)
    ssl_sock.close()
    cert = x509.load_der_x509_certificate(der_data, default_backend())
    subject_cn = ""
    issuer_cn = ""
    sans = []
    oid_cn = x509.ObjectIdentifier("2.5.4.3")
    oid_san = x509.ObjectIdentifier("2.5.29.17")
    for attribute in cert.subject:
        if attribute.oid == oid_cn:
            subject_cn = attribute.value
    for attribute in cert.issuer:
        if attribute.oid == oid_cn:
            issuer_cn = attribute.value
    for attribute in cert.extensions:
        if attribute.oid == oid_san:
            sans = sorted([x.value for x in attribute.value])
    logging.debug(
        "{}:{} ({}) expires in {}".format(
            hostname, port, subject_cn, (cert.not_valid_after - now)
        )
    )
    logging.debug("    Issuer: {}".format(issuer_cn))
    logging.debug("    SANs: {}".format(sans))
    return (
        cert.serial_number,
        cert.not_valid_before,
        cert.not_valid_after,
        subject_cn,
        issuer_cn,
        sans,
    )


if __name__ == "__main__":
    with open(sys.argv[1]) as f:
        CONFIG = yaml.safe_load(f)
    if not os.path.exists(os.path.dirname(CONFIG["write_file"])):
        sys.exit()
    logging_level = logging.DEBUG if sys.stdin.isatty() else logging.INFO
    logging.basicConfig(level=logging_level)
    dump_metrics()
