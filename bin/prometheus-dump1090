#!/usr/bin/env python3

# SPDX-FileComment: prometheus-dump1090
# SPDX-FileCopyrightText: Copyright (C) 2021 Ryan Finnie
# SPDX-License-Identifier: MPL-2.0

# Sample dump1090.yaml:
#
# stations:
# - name: piaware
#   url: http://piaware.example.lan/dump1090-fa/data/aircraft.json

import argparse
import binascii
import logging
import os
import pathlib
import platform
import random
import sys
import time

import prometheus_client
from prometheus_client import Counter, Gauge
import requests
import yaml


class BaseMetrics:
    prefix = "base"
    interval = 60
    registry = None
    args = None
    config = None
    needs_config = False
    collection_duration = None
    collection_errors = None

    def setup(self):
        pass

    def collect_metrics(self):
        pass

    def metrics_args(self, parser):
        pass

    def parse_args(self, argv=None):
        def _optional_path(string):
            return pathlib.Path(string) if string else None

        if argv is None:
            argv = sys.argv

        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
            prog=os.path.basename(argv[0]),
        )

        action_group = parser.add_mutually_exclusive_group(required=True)
        action_group.add_argument(
            "--http-daemon", action="store_true", help="Run an HTTP daemon"
        )
        action_group.add_argument(
            "--prom-daemon", action="store_true", help="Run a .prom-writing daemon"
        )
        action_group.add_argument(
            "--write", action="store_true", help="Write a .prom file"
        )
        action_group.add_argument(
            "--dump", action="store_true", help="Dump a .prom file to stdout"
        )

        parser.add_argument(
            "--prom-file",
            type=pathlib.Path,
            default="/var/lib/prometheus/node-exporter/{}.prom".format(self.prefix),
            help=".prom file to write",
            metavar="FILE",
        )
        parser.add_argument(
            "--http-port",
            type=int,
            default=(
                (binascii.crc32(self.prefix.encode("UTF-8")) & (65535 - 49152)) + 49152
            ),
            help="HTTP port number",
            metavar="PORT",
        )
        parser.add_argument(
            "--interval",
            type=float,
            default=self.interval,
            help="Seconds between collections",
            metavar="SECONDS",
        )
        parser.add_argument(
            "--interval-randomize",
            type=float,
            default=10,
            help="Randomize interval by +/- PERCENT percent, 0 to disable",
            metavar="PERCENT",
        )
        default_config_file = pathlib.Path(
            "/etc/prometheus/collectors/{}.yaml".format(self.prefix)
        )
        if (not self.needs_config) and (not default_config_file.exists()):
            default_config_file = None
        parser.add_argument(
            "--config",
            type=_optional_path,
            default=default_config_file,
            help="YAML configuration file",
            metavar="FILE",
        )

        self.metrics_args(parser)
        return parser.parse_args(args=argv[1:])

    def load_config(self):
        if not self.args.config:
            return {}
        with self.args.config.open() as f:
            return yaml.safe_load(f)

    def main(self):
        logging_level = logging.DEBUG if sys.stdin.isatty() else logging.INFO
        logging.basicConfig(level=logging_level)
        self.args = self.parse_args()
        self.interval = self.args.interval
        self.config = self.load_config()
        if self.args.http_daemon:
            self.registry = prometheus_client.REGISTRY
            self.collection_duration = prometheus_client.Summary(
                "{}_collection_duration_seconds".format(self.prefix),
                "Time spent collecting metrics",
                registry=self.registry,
            )
            self.collection_errors = prometheus_client.Counter(
                "{}_collection_errors_total".format(self.prefix),
                "Errors encountered while collecting metrics",
                registry=self.registry,
            )
        else:
            self.registry = prometheus_client.CollectorRegistry()
        self.setup()

        if self.args.http_daemon:
            prometheus_client.start_http_server(
                self.args.http_port, registry=self.registry
            )
            logging.info("HTTP server running on port {}".format(self.args.http_port))

        self.main_loop()

    def main_loop(self):
        while True:
            logging.debug("Beginning collection run")
            try:
                if self.collection_duration:
                    with self.collection_duration.time():
                        self.collect_metrics()
                else:
                    self.collect_metrics()
            except Exception:
                if self.args.write or self.args.dump:
                    raise
                else:
                    logging.exception("Encountered an error during collection")
                if self.collection_errors:
                    self.collection_errors.inc()

            if self.args.prom_daemon or self.args.write:
                prometheus_client.write_to_textfile(
                    str(self.args.prom_file), registry=self.registry
                )
            elif self.args.dump:
                output = prometheus_client.generate_latest(registry=self.registry)
                print(output.decode("UTF-8"), end="")
            if self.args.write or self.args.dump:
                return

            if self.args.http_daemon or self.args.prom_daemon:
                sleep = random.uniform(
                    self.interval * (1 - (self.args.interval_randomize / 100.0)),
                    self.interval * (1 + (self.args.interval_randomize / 100.0)),
                )
                logging.debug("Sleeping for {}".format(sleep))
                time.sleep(sleep)


class Metrics(BaseMetrics):
    prefix = "dump1090"

    def setup(self):
        self.metrics = {}
        # < 58 and < 60 mirrors the logic of the PiAware 5.0 JS UI
        self.seen_fresh_time = self.config.get("seen_fresh_time", 58)
        self.seen_pos_fresh_time = self.config.get("seen_pos_fresh_time", 60)
        label_names = ["station"]

        defs = [
            ("reports_total", Counter, "Total reports received"),
            ("station_time_seconds", Gauge, "Station collection time"),
            ("messages_received", Gauge, "Number of raw messages received"),
            (
                "airborne_aircraft_total",
                Gauge,
                "Total number of current airborne aircraft seen",
            ),
            (
                "airborne_aircraft_positions",
                Gauge,
                "Number of current airborne aircraft seen with positions",
            ),
            (
                "airborne_aircraft_mlat",
                Gauge,
                "Number of current airborne aircraft seen with multilateration",
            ),
            (
                "airborne_aircraft_tisb",
                Gauge,
                "Number of current airborne aircraft seen with TIS-B information",
            ),
            (
                "airborne_aircraft_squawk",
                Gauge,
                "Number of current airborne aircraft seen squawking",
            ),
            (
                "airborne_aircraft_ground",
                Gauge,
                "Number of current aircraft reported on ground",
            ),
            (
                "airborne_aircraft_messages",
                Gauge,
                "Number of messages received by currently seen airborne aircraft",
            ),
        ]

        for k, t, h in defs:
            self.metrics[k] = t(
                "{}_{}".format(self.prefix, k), h, label_names, registry=self.registry
            )

        if "stations" not in self.config:
            self.config["stations"] = [
                {
                    "name": platform.node(),
                    "url": "http://127.0.0.1/dump1090-fa/data/aircraft.json",
                }
            ]

    def collect_metrics(self):
        for station in self.config["stations"]:
            self.collect_station(station)

    def collect_station(self, station):
        r = requests.get(station["url"])
        r.raise_for_status()
        j = r.json()
        aircraft = [x for x in j["aircraft"] if x["seen"] < self.seen_fresh_time]

        labels = [station["name"]]
        vals = [
            ("messages_received", j["messages"]),
            ("airborne_aircraft_total", len(aircraft)),
            (
                "airborne_aircraft_positions",
                len(
                    [
                        x
                        for x in aircraft
                        if "lat" in x
                        and "seen_pos" in x
                        and x["seen_pos"] < self.seen_pos_fresh_time
                    ]
                ),
            ),
            ("airborne_aircraft_mlat", len([x for x in aircraft if x.get("mlat")])),
            ("airborne_aircraft_tisb", len([x for x in aircraft if x.get("tisb")])),
            ("airborne_aircraft_squawk", len([x for x in aircraft if x.get("squawk")])),
            (
                "airborne_aircraft_ground",
                len([x for x in aircraft if x.get("alt_baro") == "ground"]),
            ),
            (
                "airborne_aircraft_messages",
                sum([x["messages"] for x in aircraft if "messages" in x]),
            ),
            ("station_time_seconds", j["now"]),
        ]
        for k, v in vals:
            self.metrics[k].labels(*labels).set(v)
        self.metrics["reports_total"].labels(*labels).inc()


if __name__ == "__main__":
    sys.exit(Metrics().main())
